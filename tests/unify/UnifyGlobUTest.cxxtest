/**
 * UnifyGlobUTest.cxxtest
 *
 * Copyright (C) 2019 OpenCog Foundation
 * All Rights Reserved
 * Author: Kasim
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/util/Logger.h>

#include <opencog/atoms/core/Context.h>
#include <opencog/unify/Unify.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/SchemeEval.h>

#include <cxxtest/TestSuite.h>

using namespace opencog;

#define al _as.add_link
#define an _as.add_node

class UnifyGlobUTest :  public CxxTest::TestSuite
{
private:
	AtomSpace _as;
	SchemeEval _eval;
	Handle X, Y, U, V, W;
	Handle P, Q, R, S, T, D;
	Handle C1, C2;
	Handle PQ, lX;
	Handle UNXY, UNQRP, UNQRPS, UNC1C2, UNC1C2S, UNXYP, UNXYPQ, UNSC1U, UNQSC1U, UNXYUVW, UNSTDC1C2,
			UNUVAND, UNSDRAND;

	Context::VariablesStack X_varstack;

public:
	UnifyGlobUTest() : _eval(&_as)
	{
		logger().set_level(Logger::DEBUG);
		logger().set_print_to_stdout_flag(true);
		logger().set_timestamp_flag(false);

		X = an(GLOB_NODE, "$X");
		Y = an(GLOB_NODE, "$Y");
		U = an(GLOB_NODE, "$U");
		V = an(GLOB_NODE, "$V");
		W = an(GLOB_NODE, "$W");

		P = an(PREDICATE_NODE, "P");
		Q = an(PREDICATE_NODE, "Q");
		R = an(PREDICATE_NODE, "R");
		S = an(PREDICATE_NODE, "S");
		T = an(PREDICATE_NODE, "T");
		D = an(PREDICATE_NODE, "D");

		C1 = an(CONCEPT_NODE, "C1");
		C2 = an(CONCEPT_NODE, "C2");

		PQ = al(LIST_LINK, {P, Q});
		HandleSeq seq = {X};
		lX = al(LIST_LINK, seq);

		UNXY = al(AND_LINK, {X, Y});
		UNQRP = al(AND_LINK, {Q, R, P});
		UNQRPS = al(AND_LINK, {Q, R, P, S});
		UNC1C2 = al(AND_LINK, {C1, C2});
		UNC1C2S = al(AND_LINK, {C1, C2, S});
		UNXYP = al(AND_LINK, {X, Y, P});
		UNXYPQ = al(AND_LINK, {X, Y, P, Q});
		UNSC1U = al(AND_LINK, {S, C1, U});
		UNQSC1U = al(AND_LINK, {Q, S, C1, U});
		UNXYUVW = al(AND_LINK, {X, Y, U, V, W});
		UNSTDC1C2 = al(AND_LINK, {S, T, D, C1, C2});

		UNUVAND = al(AND_LINK, {U, V, UNXY});
		UNSDRAND = al(AND_LINK, {S, D, R, UNC1C2});
	}

	void setUp();

	// TODO: THIS UNIT TESTS ARE VALID UNTIL JOINING SOLUTIONS THAT CONTAIN
	//  GLOB_NODE IS SUPPORTED. UPDATE AS SOON AS JOIN IS IMPLEMENTED.
	void test_simple_glob();
	void test_simple_glob2();
	void test_simple_glob3();
	void test_simple_glob3_alt();
	void test_simple_glob4();
	void test_simple_glob5();
	void test_simple_glob6();
	void test_simple_glob7();
	void test_simple_glob8();

	void test_typed_glob1();

	void test_join();
};

void UnifyGlobUTest::setUp(void)
{
}

void UnifyGlobUTest::test_simple_glob()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
			                            "(GlobNode \"g\")"
			                            "(TypeNode \"PredicateNode\"))");

	Unify unify(X, P, left_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob2()
{
	Unify unify(X, PQ);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, PQ}, PQ}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob3()
{
	Unify unify(UNQRP, UNXY);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}, {{Y, P}, P}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{X, P}, P}},
	                             {{{Y, Q}, Q}, {{X, R}, R}, {{X, P}, P}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{Y, P}, P}},
	                             {{{Y, Q}, Q}, {{X, R}, R}, {{Y, P}, P}},
	                             {{{Y, Q}, Q}, {{Y, R}, R}, {{X, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob3_alt()
{
	Unify unify(UNC1C2, UNXY);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, C1}, C1}, {{Y, C2}, C2}}, {{{X, C2}, C2}, {{Y, C1}, C1}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob4()
{
	Unify unify(UNXY, UNQRP);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}, {{Y, P}, P}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{X, P}, P}},
	                             {{{Y, Q}, Q}, {{X, R}, R}, {{X, P}, P}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{Y, P}, P}},
	                             {{{Y, Q}, Q}, {{X, R}, R}, {{Y, P}, P}},
	                             {{{Y, Q}, Q}, {{Y, R}, R}, {{X, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob5()
{
	Unify unify(UNXY, UNQRPS);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}, {{X, P}, P}, {{Y, S}, S}},
	                             {{{X, Q}, Q}, {{X, R}, R}, {{Y, P}, P}, {{X, S}, S}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{X, P}, P}, {{X, S}, S}},
	                             {{{Y, Q}, Q}, {{X, R}, R}, {{X, P}, P}, {{X, S}, S}},
	                             {{{Y, Q}, Q}, {{Y, R}, R}, {{Y, S}, S}, {{X, P}, P}},
	                             {{{Y, Q}, Q}, {{Y, R}, R}, {{X, S}, S}, {{Y, P}, P}},
	                             {{{Y, Q}, Q}, {{X, R}, R}, {{Y, S}, S}, {{Y, P}, P}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{Y, S}, S}, {{Y, P}, P}},
	                             {{{X, Q}, Q}, {{X, R}, R}, {{Y, P}, P}, {{Y, S}, S}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{X, P}, P}, {{Y, S}, S}},
	                             {{{Y, Q}, Q}, {{X, R}, R}, {{X, P}, P}, {{Y, S}, S}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{Y, P}, P}, {{X, S}, S}},
	                             {{{Y, Q}, Q}, {{X, R}, R}, {{Y, P}, P}, {{X, S}, S}},
	                             {{{Y, Q}, Q}, {{Y, R}, R}, {{X, P}, P}, {{X, S}, S}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob6()
{
	Unify unify(UNXYPQ, UNSC1U);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{U, Q}, Q}, {{U, P}, P}, {{Y, C1}, C1}, {{X, S}, S}},
	                             {{{Y, S}, S}, {{X, C1}, C1}, {{U, Q}, Q}, {{U, P}, P}}});

	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob7()
{
	Unify unify(UNXYUVW, UNSTDC1C2);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	// TODO check again
	Arity expected_size = 120;

	TS_ASSERT_EQUALS(result.size(), expected_size);
}

void UnifyGlobUTest::test_simple_glob8()
{
	Unify unify(UNUVAND, UNSDRAND);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{U, S}, S}, {{U, D}, D}, {{V, R}, R}, {{Y, C1}, C1}, {{X, C2}, C2}},
	                             {{{U, S}, S}, {{U, D}, D}, {{V, R}, R}, {{Y, C2}, C2}, {{X, C1}, C1}},
	                             {{{U, S}, S}, {{V, D}, D}, {{U, R}, R}, {{Y, C1}, C1}, {{X, C2}, C2}},
	                             {{{U, S}, S}, {{V, D}, D}, {{U, R}, R}, {{Y, C2}, C2}, {{X, C1}, C1}},
	                             {{{V, S}, S}, {{U, D}, D}, {{U, R}, R}, {{Y, C1}, C1}, {{X, C2}, C2}},
	                             {{{V, S}, S}, {{U, D}, D}, {{U, R}, R}, {{Y, C2}, C2}, {{X, C1}, C1}},
	                             {{{V, S}, S}, {{V, D}, D}, {{U, R}, R}, {{Y, C1}, C1}, {{X, C2}, C2}},
	                             {{{V, S}, S}, {{V, D}, D}, {{U, R}, R}, {{Y, C2}, C2}, {{X, C1}, C1}},
	                             {{{V, S}, S}, {{U, D}, D}, {{V, R}, R}, {{Y, C1}, C1}, {{X, C2}, C2}},
	                             {{{V, S}, S}, {{U, D}, D}, {{V, R}, R}, {{Y, C2}, C2}, {{X, C1}, C1}},
	                             {{{U, S}, S}, {{V, D}, D}, {{V, R}, R}, {{Y, C1}, C1}, {{X, C2}, C2}},
	                             {{{U, S}, S}, {{V, D}, D}, {{V, R}, R}, {{Y, C2}, C2}, {{X, C1}, C1}}});

	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_typed_glob1()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
	                                   "(GlobNode \"$X\")"
	                                   "(TypeNode \"PredicateNode\"))");

	Unify unify(UNXYP, UNQSC1U, left_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, S}, S}, {{Y, C1}, C1}, {{U, P}, P}}});

	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_join()
{
	Unify unify(P, Q);
	Unify::Block b1({X, P});
	Unify::Block b2({X, Q});
	Unify::SolutionSet s1({{{b1, P}}});
	Unify::SolutionSet s2({{{b2, Q}}});

	auto result = unify.join(s1, s2);
	Unify::SolutionSet expected({{{b1, P}, {b2, Q}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

#undef al
#undef an
