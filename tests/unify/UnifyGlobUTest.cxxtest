/**
 * UnifyGlobUTest.cxxtest
 *
 * Copyright (C) 2019 OpenCog Foundation
 * All Rights Reserved
 * Author: Kasim
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/util/Logger.h>

#include <opencog/atoms/core/Context.h>
#include <opencog/unify/Unify.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/SchemeEval.h>

#include <cxxtest/TestSuite.h>

using namespace opencog;

#define al _as.add_link
#define an _as.add_node

class UnifyGlobUTest :  public CxxTest::TestSuite
{
private:
	AtomSpace _as;
	SchemeEval _eval;
	Handle X, Y, P, Q, R, PQ, UNXY, UNQRP, lX;
	Context::VariablesStack X_varstack;

public:
	UnifyGlobUTest() : _eval(&_as)
	{
		logger().set_level(Logger::DEBUG);
		logger().set_print_to_stdout_flag(true);
		logger().set_timestamp_flag(false);

		X = an(GLOB_NODE, "$X");
		Y = an(GLOB_NODE, "$Y");

		P = an(PREDICATE_NODE, "P");
		Q = an(PREDICATE_NODE, "Q");
		R = an(PREDICATE_NODE, "R");

		PQ = al(LIST_LINK, {P, Q});
		UNXY = al(AND_LINK, {X, Y});
		UNQRP = al(AND_LINK, {Q, R, P});

		HandleSeq seq = {X};
		lX = al(LIST_LINK, seq);
	}

	void setUp();

	void test_simple_glob();
	void test_simple_glob2();
	void test_simple_glob3();
	void test_simple_glob4();
};

void UnifyGlobUTest::setUp(void)
{
}

void UnifyGlobUTest::test_simple_glob()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
			                            "(GlobNode \"g\")"
			                            "(TypeNode \"PredicateNode\"))");

	Unify unify(X, P, left_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob2()
{
	Unify unify(X, PQ);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, PQ}, PQ}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob3()
{
	Unify unify(UNQRP, UNXY);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}}, {{{X, R}, R}}, {{{Y, P}, P}},
	                             {{{X, Q}, Q}}, {{{Y, R}, R}}, {{{X, P}, P}},
	                             {{{Y, Q}, Q}}, {{{X, R}, R}}, {{{X, P}, P}},
	                             {{{X, Q}, Q}}, {{{Y, R}, R}}, {{{Y, P}, P}},
	                             {{{Y, Q}, Q}}, {{{X, R}, R}}, {{{Y, P}, P}},
	                             {{{Y, Q}, Q}}, {{{Y, R}, R}}, {{{X, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob4()
{
	Unify unify(UNXY, UNQRP);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}}, {{{X, R}, R}}, {{{Y, P}, P}},
	                             {{{X, Q}, Q}}, {{{Y, R}, R}}, {{{X, P}, P}},
	                             {{{Y, Q}, Q}}, {{{X, R}, R}}, {{{X, P}, P}},
	                             {{{X, Q}, Q}}, {{{Y, R}, R}}, {{{Y, P}, P}},
	                             {{{Y, Q}, Q}}, {{{X, R}, R}}, {{{Y, P}, P}},
	                             {{{Y, Q}, Q}}, {{{Y, R}, R}}, {{{X, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

#undef al
#undef an
