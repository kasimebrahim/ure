/**
 * UnifyGlobUTest.cxxtest
 *
 * Copyright (C) 2019 OpenCog Foundation
 * All Rights Reserved
 * Author: Kasim
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/util/Logger.h>

#include <opencog/atoms/core/Context.h>
#include <opencog/unify/Unify.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/SchemeEval.h>

#include <cxxtest/TestSuite.h>

using namespace opencog;

#define al _as.add_link
#define an _as.add_node

class UnifyGlobUTest :  public CxxTest::TestSuite
{
private:
	AtomSpace _as;
	SchemeEval _eval;
	Handle X, Y, P, Q, R, S, A, B, C, D, PQ, XP, RQSY, QRP, XY, lX, y, QRy, X2, Y2, XX2P,
			QlXP, QlQRP, ABCXR, YCPQR, XYDABC, QRPyX2Y2, UNXY, UNQRP,ABR;
	Context::VariablesStack X_varstack;

public:
	UnifyGlobUTest() : _eval(&_as)
	{
		logger().set_level(Logger::DEBUG);
		logger().set_print_to_stdout_flag(true);
		logger().set_timestamp_flag(false);

		X = an(GLOB_NODE, "$X");
		X2 = an(GLOB_NODE, "$X2");
		Y = an(GLOB_NODE, "$Y");
		Y2 = an(GLOB_NODE, "$Y2");
		y = an(VARIABLE_NODE, "$y");

		P = an(PREDICATE_NODE, "P");
		Q = an(PREDICATE_NODE, "Q");
		R = an(PREDICATE_NODE, "R");
		S = an(PREDICATE_NODE, "S");

		A = an(CONCEPT_NODE, "A");
		B = an(CONCEPT_NODE, "B");
		C = an(CONCEPT_NODE, "C");
		D = an(CONCEPT_NODE, "D");

		PQ = al(LIST_LINK, {P, Q});
		XP = al(LIST_LINK, {X, P});
		RQSY = al(LIST_LINK, {R, Q, S, Y});
		XY = al(LIST_LINK, {X, Y});
		QRP = al(LIST_LINK, {Q, R, P});
		QRy = al(LIST_LINK, {Q, R, y});
		XX2P = al(LIST_LINK, {X, X2, P});
		QlXP = al(LIST_LINK, {Q, XP});
		QlQRP = al(LIST_LINK, {Q, QRP});
		ABR = al(LIST_LINK, {A, B, R});
		ABCXR = al(LIST_LINK, {A, B, C, X, R});
		YCPQR = al(LIST_LINK, {Y, C, P, Q, R});
		XYDABC = al(LIST_LINK, {X, Y, D, A, B, C});
		QRPyX2Y2 = al(LIST_LINK, {Q, R, P, y, X2, Y2});

		HandleSeq seq = {X};
		lX = al(LIST_LINK, seq);

		UNXY = al(AND_LINK, {X, Y});
		UNQRP = al(AND_LINK, {Q, R, P});
	}

	void setUp();

	void test_simple_glob();
	void test_simple_glob2();
	void test_simple_glob3();
	void test_simple_glob4();
	void test_simple_glob5();
	void test_simple_glob5_alt();
	void test_simple_glob6();
	void test_simple_glob7();
	void test_simple_glob8();
	void test_simple_glob9();
	void test_simple_glob10();

	void test_typed_glob1();
	void test_typed_glob2();
	void test_typed_glob3();
	void test_typed_glob3_alt();

	void test_join();

	void test_simple_unordered_glob3();
};

void UnifyGlobUTest::setUp(void)
{
}

void UnifyGlobUTest::test_simple_glob()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
			                            "(GlobNode \"g\")"
			                            "(TypeNode \"PredicateNode\"))");

	Unify unify(X, P, left_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob2()
{
	Unify unify(X, PQ);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, PQ}, PQ}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob3()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
			                                   "(GlobNode \"g\")"
			                                   "(TypeNode \"PredicateNode\"))");

	Unify unify(XP, QRP, left_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob4()
{
	Unify unify(lX, PQ);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob5()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
			                                   "(GlobNode \"g\")"
			                                   "(TypeNode \"PredicateNode\"))");

	Unify unify(XX2P, QRP, left_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X2, R}, R}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob5_alt()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
	                                   "(GlobNode \"g\")"
	                                   "(TypeNode \"PredicateNode\"))");

	Unify unify(XX2P, RQSY, left_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}, {{X2, S}, S}, {{Y, P}, P}},
	                             {{{X2, Q}, Q}, {{X, R}, R}, {{X2, S}, S}, {{Y, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob6()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
			                                   "(GlobNode \"g\")"
			                                   "(TypeNode \"PredicateNode\"))");

	Unify unify(XP, QRy, left_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}, {{y, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob7()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
			                                   "(GlobNode \"g\")"
			                                   "(TypeNode \"PredicateNode\"))");

	Unify unify(QlXP, QlQRP, left_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob8()
{
	Unify unify(QRP, XP);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob9()
{
	Unify unify(XY, QRP);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}, {{Y, P}, P}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{Y, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_glob10()
{
	Unify unify(QRP, XY);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}, {{Y, P}, P}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{Y, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_typed_glob1()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
	                                   "(GlobNode \"$X\")"
	                                   "(TypeNode \"PredicateNode\"))");
	Handle right_vardecl = _eval.eval_h("(TypedVariable"
	                                   "(GlobNode \"$Y\")"
	                                   "(TypeNode \"ConceptNode\"))");

	Unify unify(ABCXR, YCPQR, left_vardecl, right_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{Y, A}, A}, {{Y, B}, B}, {{X, P}, P}, {{X, Q}, Q}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_typed_glob2()
{
	Unify unify(XYDABC, QRPyX2Y2);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}, {{X, R}, R}, {{X, P}, P}, {{y, Y}, Y},
	                              {{X2, A}, A}, {{X2, B}, B}, {{X2, D}, D}, {{Y2, C}, C}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{Y, P}, P}, {{y, D}, D},
	                              {{X2, A}, A}, {{X2, B}, B}, {{Y2, C}, C}},
	                             {{{X, Q}, Q}, {{X, R}, R}, {{Y, P}, P}, {{y, D}, D},
	                              {{X2, A}, A}, {{X2, B}, B}, {{Y2, C}, C}},
	                             {{{X, Q}, Q}, {{X, R}, R}, {{X, P}, P}, {{y, Y}, Y},
	                              {{X2, A}, A}, {{Y2, B}, B}, {{X2, D}, D}, {{Y2, C}, C}},
	                             {{{X, Q}, Q}, {{X, R}, R}, {{X, P}, P}, {{y, Y}, Y},
	                              {{Y2, A}, A}, {{Y2, B}, B}, {{X2, D}, D}, {{Y2, C}, C}},
	                             {{{X, Q}, Q}, {{Y, R}, R}, {{Y, P}, P}, {{y, D}, D},
	                              {{X2, A}, A}, {{Y2, B}, B}, {{Y2, C}, C}},
	                             {{{X, Q}, Q}, {{X, R}, R}, {{Y, P}, P}, {{y, D}, D},
	                              {{X2, A}, A}, {{Y2, B}, B}, {{Y2, C}, C}}});
	std::cout << "\n expected\n" << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_typed_glob3()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
	                                   "(GlobNode \"$X\")"
	                                   "(TypeNode \"PredicateNode\"))");
	Handle right_vardecl = _eval.eval_h("(TypedVariable"
	                                    "(GlobNode \"$Y\")"
	                                    "(TypeNode \"ConceptNode\"))");

	Unify unify(ABR, XY, left_vardecl, right_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_typed_glob3_alt()
{
	Handle left_vardecl = _eval.eval_h("(TypedVariable"
	                                   "(GlobNode \"$Y\")"
	                                   "(TypeNode \"PredicateNode\"))");
	Handle right_vardecl = _eval.eval_h("(TypedVariable"
	                                    "(GlobNode \"$X\")"
	                                    "(TypeNode \"ConceptNode\"))");

	Unify unify(ABR, XY, left_vardecl, right_vardecl);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, A}, A}, {{X, B}, B}, {{Y, R}, R}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_join()
{
	Unify unify(P, Q);
	Unify::Block b1({X, P});
	Unify::Block b2({X, Q});
	Unify::SolutionSet s1({{{b1, P}}});
	Unify::SolutionSet s2({{{b2, Q}}});

	auto result = unify.join(s1, s2);
	Unify::SolutionSet expected({{{b1, P}, {b2, Q}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

void UnifyGlobUTest::test_simple_unordered_glob3()
{
	Unify unify(UNQRP, UNXY);
	Unify::SolutionSet result = unify();
	std::cout<< "\n result\n" << oc_to_string(result) <<std::endl;

	Unify::SolutionSet expected({{{{X, Q}, Q}}, {{{X, R}, R}}, {{{Y, P}, P}},
	                             {{{X, Q}, Q}}, {{{Y, R}, R}}, {{{X, P}, P}},
	                             {{{X, Q}, Q}}, {{{Y, R}, R}}, {{{Y, P}, P}},
	                             {{{Y, Q}, Q}}, {{{X, R}, R}}, {{{X, P}, P}},
	                             {{{Y, Q}, Q}}, {{{X, R}, R}}, {{{Y, P}, P}},
	                             {{{Y, Q}, Q}}, {{{Y, R}, R}}, {{{X, P}, P}}});
	std::cout<< "\n expected\n" << oc_to_string(expected) <<std::endl;

	TS_ASSERT_EQUALS(result, expected);
}

#undef al
#undef an
